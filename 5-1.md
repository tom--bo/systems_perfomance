# 5. Applications
パフォーマンスは作業を実行するところ、つまりアプリケーションをチューニングすることが最良である。  
これにはデータベース、ウェブサーバ、アプリケーションサーバ、ロードバランサ、ファイルサーバなどなどが含まれる。  
この章以降ではではアプリケーションが消費するリソース、つまりCPU、 メモリ、ファイルシステム、ディスク、ネットワークといった観点からアプリケーションを見ていく。  
この章ではアプリケーションレベルについて述べる。  

アプリケーション、特に複数のコンポーネントを含む分散環境にあるアプリケーションは非常に複雑になり得る。  
これらは通常、サードパーティのツールも含めてアプリケーションデベロッパの管轄である。  
システムアドミニストレータを含むこれらの人が、コンフィギュレーション（以降、構成）を含むシステムパフォーマンスについて学ぶことは、システムリソースをより効率よく使うことにとても有効である。  

## 5.1 Application Basics

アプリケーションパフォーマンスに飛び込む前にアプリケーションの役割に習熟する必要がある。  
これは基本的な特徴付けで、業界のエコシステムでもある。  
これはあなたがアプリケーションの活動を理解するコンテキストを形作ってくれる。  
更に、一般的なパフォーマンス問題とその解決策を学ぶ機会となり、さらなる学習のための手法となるだろう。  
こういったコンテキストを学ぶために以下の質問に答えてみよう

- Function（機能）
  - アプリケーションの役割は何か
  - DB?Webサーバ？ロードバランサ？
- Operation（動作）
  - アプいケーションはどんなリクエストを捌くか。
  - DBはクエリを、WebサーバはHTTPリクエストをさばく
- CPU model
  - アプリケーションはカーネルレベルで動作するのかゆーざれべるなのか。
  - 大抵はユーザレベルだが、NFSのようにカーネルレベルのものもある。
- Configuration（構成）
  - どのように構成されているのか。なぜか。
  - これらはconfファイルか管理ツールで見つかるだろう
  - パフォーマンスに関連する設定が変更されていたら注意する
- Metrics
  - どういったメトリクスが提供されているか
- Logs
  - アプリケーションはどういったログを出しているか
  - パフォーマンスに関連するログをだせるか
- Version
  - 最新のバージョンを使っているか
- Bugs
  - バグはあるか、パフォーマンスに関連するものはあるか
- Community
  - パフォーマンスに関することを共有しているコミュニティはあるか
- Books
  - パフォーマンスに関する本はあるか
- Experts
  - そのアプリケーションに関するスペシャリストはいるか


### 5.1.1 Objectives

パフォーマンス改善におけるゴールはどういった対処をするかの指針になってくれる。  
明確なゴールを決めない作業は"fishing expedition"になってしまう。

アプリケーションパフォーマンスに関するゴールであれば以下の様なものになるだろう
- Latency : アプリケーションのレスポンスタイム
- Throughput : アプリケーションの稼働率やデータの転送率
- Resource utiliation : 負荷に対する仕事率

これらを定量化出来るとなお良いだろう。例えば
- リクエストに対する平均レイテンシを5msにする
- 95%のリクエストのレイテンシを100ms以下にする
- 応答に1000ms以上かかるリクエストをなくす
- 1秒辺り10000リクエストのアプリケーションで、ディスク利用率を50%以下にする

一度ゴールを決めてしまえば、後はそれに対して作業をし始められる。  
問題の特定と解決はこれ以降の章の内容が手助けしてくれるだろう。  

スループットに対する目標はパフォーマンスやコストの観点による作業と同じではない。  
もし目標が稼働率ベースならそのアプリケーションがどういったタイプか見極める必要がある。  


### 5.1.2 Optimize the Common Case

ソフトウェアの内部は非常に複雑になっており、様々なコードパスが存在する。  
これらをランダムに探検するのは膨大な労力が必要で、かつ得られるものはそれほど無いだろう。  

改善への有効な方法は、もっともよく使われているコードパスから手を付けることだろう。  
CPUバウンドなアプリケーションであればCPUをもっとも使っている部分を、IOバウンドであればIOをよく発生させている部分から手を付けよう。  
これらは以降の章でカバーされているプロファイリングやスタックトレースによって理解することが出来る。

### 5.1.3 Observability

この本で何度も説明しているように、OSにおいてパフォーマンスがかつのは常に不要な処理を削除した時である。  
これはアプリケーションでも同様である。  
この事実はパフォーマンスの観点からシステムを選択するときにも見られるが、処理が多少遅かったとしても、きちんとしたロギングやパフォーマンス監視の機構のあるシステムを選ぶことが長期的には優っていることもある。


### 5.1.4 Big O Notation

Big O記法は一般的なコンピュータサイエンスの科目で習うものであり、アルゴリズムの複雑度を測り、データセットのスケールに対してモデリングするものである。  
これらを意識することはシステムを開発する上で効果的である。

（表5.1 Big O記法とサンプルのアルゴリズム）  
（Big O記法とオーダーによる実行時間の比較図）  


## 5.2 Application Performance Techniques

この章ではアプリケーションのパフォーマンス改善において一般的なテクニックを紹介する。  


### 5.2.1 Selecting an I/O Size

I/Oに関連するパフォーマンスコストは以下の様なものが含まれる。  
バッファの初期化、システムコールの発行、コンテキストスイッチ、カーネルメタデータの配置、プロセスの権限の確認と制限、デバイスとアドレスのマッピング、カーネルとデバイスコードの実行、そして最後にメタデータやバッファの解放。  
I/Oが大きかろうと少なかろうと"初期化"という税を毎回払っている。

I/Oのサイズを大きくすることはアプリケーションのスループットを改善する一般的な戦略である。  
大抵の場合、128KBの一回のI/Oを発行するほうが、1KBの128回のI/Oを行うより効率が良い。  
一方で、巨大なI/Oサイズが裏目に出ることもある。  
データベースが8KBのランダムアクセスを行う時、128KBのI/Oでは120KBが無駄な転送になってしまう。  
また、不必要なほど巨大なI/Oはキャッシュサイズも無駄に埋めてしまうことになる。


### 5.2.2 Caching

OSはファイルへのreadやメモリ配置のパフォーマンスを向上するためにキャッシュを利用していて、アプリケーションもしばしば同じ理由でキャッシュを利用する。  
重い処理を何度も実行する代わりに、一度実行したものを将来また使うことを見越してローカルにキャッシュしておくのである。  
一般的なタスクは、どのデータをキャッシュするか決定し、（またはキャッシュを有効化し）そのサイズをサイズを適切に設定することである。

最も肝心なことは統一性を保つことと、古くなったキャッシュデータを返さないようにすることである。  
readの性能はキャッシュによって向上し、writeの性能はこの後のバッファリングによって向上する。


### 5.2.3 Buffering

writeのパフォーマンスを向上するために、データを次のレベルのストレージに送る前にバッファリングすることがある。  
これはI/Oサイズとその処理の効率を向上する。  
writeの発生の仕方にもよるが、バッファリングをすることによってレイテンシが増えることもある。

### 5.2.4 Polling



### 5.2.5 Concurrency and Parallelism



### 5.2.6 Non-Blocking I/O



### 5.2.7 Processor Binding





## 5.3 Programming Languages


### 5.3.1 Compiled Languages


### 5.3.2 Interpreted Languages



### 5.3.3 Virtual Machines



### 5.3.4 Garbage Collection












.
